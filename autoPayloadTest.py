import sys
sys.path.insert(0, '../vm-automation/src')

import workstationVm
import apt_shared
import esxiVm

import time
import hashlib
import os
import json

def bailSafely(testVmList, devVm):
        if devVm != None:
            devVm.revertDevVm()
            devVm.powerOff()
        for i in testVmList:
            i.revertToTestingBase()
            i.powerOff()
        exit(1)
    
def main():
    
    testVms = []
    devVm = None
    usageStatement = "autoPayloadTest <infrastructure.conf> <test.conf>"
    if len(sys.argv) != 3:
        print "INCORRECT PARAMETER LIST:\n " + usageStatement
        bailSafely(testVms, devVm)

    infrastructureJsonFile =    sys.argv[1]
    testJsonFile =              sys.argv[2]

    """
    LOAD HYPERVISOR CONFIG VALUES
    """
    infrastructureConfig =  apt_shared.loadJson(infrastructureJsonFile)
    if infrastructureConfig == None:
        bailSafely(testVms, devVm)
    try:
        hyperVisorType =        infrastructureConfig['HYPERVISOR_TYPE']
    except KeyError as e:
        apt_shared.logMsg("FAILED TO LOAD INFRASTRUCTURE DATA:" + str(e))
        bailSafely(testVms, devVm)
        
    for i in infrastructureConfig:
        if 'PASSWORD' in i:
            passwdObj = hashlib.sha512(infrastructureConfig[i].encode())
            apt_shared.logMsg(str(i) + "[SHA512] = " + str(passwdObj.hexdigest()))
        else:
            apt_shared.logMsg(str(i) + " = " + str(infrastructureConfig[i]))
    testConfig =            apt_shared.loadJson(testJsonFile) 
    if testConfig == None:
        bailSafely(testVms, devVm)
    try:
        bindLaunchScript =      testConfig['BIND_SCRIPT']
        devVmData =             testConfig['DEV_VM_DATA']
        httpPort =              testConfig['HTTP_PORT']
        payloadCreationScript = testConfig['PAYLOAD_CREATION_SCRIPT']
        testVmScriptName =      testConfig['TEST_SCRIPT']
        testVmData =            testConfig['TEST_VM_DATA']
        startingPortNum =       testConfig['STARTING_LISTENER']
        successList =           testConfig['SUCCESS_LIST']
        cmdList =               testConfig['COMMAND_LIST']
        payloadTypeList =       testConfig['PAYLOAD_LIST']
        testName =              testConfig['TEST_NAME']
        reportPrefix =          testConfig['REPORT_PREFIX']
    except KeyError as e:
        apt_shared.logMsg("FAILED TO LOAD " + str(e) + " FROM " + testJsonFile)
        bailSafely(testVms, devVm)

    """
    CHECK IF WE NEED EXECUTABLE PATH FOR PYTHON OR JAVA:
    THIS IS REPETITIVE, I KNOW.  CLEAN IT UP LATER WHEN I KNOW ALL OPTIONS
    """
    for i in testConfig['PAYLOAD_LIST']:
        if 'python' in i.lower():
            if 'TEST_PYTHON_EXE' not in testConfig:
                apt_shared.logMsg("PYTHON PAYLOAD SPECIFIED BUT NO PYTHON EXECUTABLE PATH PROVIDED IN CONFIG")
                bailSafely(testVms, devVm)
        if 'java' in i.lower():
            if 'TEST_JAVA_EXE' not in testConfig: 
                apt_shared.logMsg("JAVA PAYLOAD SPECIFIED BUT NO JAVA EXECUTABLE PATH PROVIDED IN CONFIG")
                bailSafely(testVms, devVm)
            
    for i in testConfig:
        if 'PASSWORD' in i:
            passwdObj = hashlib.sha512(testConfig[i].encode())
            apt_shared.logMsg(str(i) + "[SHA512] = " + str(passwdObj.hexdigest()))
        else:
            apt_shared.logMsg(str(i) + " = " + str(testConfig[i]))
    if 'TEST_PYTHON_EXE' in testConfig:
        apt_shared.logMsg("USING PYTHON BINARY FILE: " + testConfig['TEST_PYTHON_EXE'])
    if 'TEST_JAVA_EXE' in testConfig:
        apt_shared.logMsg("USING JAVA BINARY FILE: " + testConfig['TEST_JAVA_EXE'])

    """
    SET UP DIRECTORIES
    """
    testConfig['TIMESTAMP'] =   str(time.time()).split('.')[0]
    testConfig['DATA_DIR']  =   os.getcwd() + "/" + "test_data"
    testConfig['TEST_DIR'] =    testConfig['DATA_DIR'] + "/" + reportPrefix + "_" + testConfig['TIMESTAMP']
    testConfig['REPORT_DIR'] =  testConfig['TEST_DIR'] + "/" + "reports"
    testConfig['SESSION_DIR'] = testConfig['TEST_DIR'] + "/" + "sessions"
    testConfig['SCRIPT_DIR'] =  testConfig['TEST_DIR'] + "/" + "scripts"

    if not os.path.exists(testConfig['DATA_DIR']):
        os.makedirs(testConfig['DATA_DIR'])
    if not os.path.exists(testConfig['TEST_DIR']):
        os.makedirs(testConfig['TEST_DIR'])
    if not os.path.exists(testConfig['REPORT_DIR']):
        os.makedirs(testConfig['REPORT_DIR'])
    if not os.path.exists(testConfig['SESSION_DIR']):
        os.makedirs(testConfig['SESSION_DIR'])
    if not os.path.exists(testConfig['SCRIPT_DIR']):
        os.makedirs(testConfig['SCRIPT_DIR'])

    """
    UNIQUE, SEQUENTIAL PORT NUMBERS FOR LISTENING/CALLBACK ARE GENERATED BY A SINGLETON-TYPE CLASS MONSTROSITY; PREP IT
    """
    portNum = apt_shared.portValue(startingPortNum)

    """ 
    DETERMINE HYPERVISOR TYPE AND SET UP HYPERVISOR METADATA
    """
    if hyperVisorType == None:
        apt_shared.logMsg("ERROR: NO HYPERVISOR_TYPE DEFINED IN CONFIG FILE")
        bailSafely(testVms, devVm)
    if hyperVisorType.lower() == 'workstation':
        try:
            vmrunExe =          testConfig['VMRUN_EXE_PATH']
            vmPath =            testConfig['VM_PATH']
            vmServer = workstationVm.workstationServer(vmrunExe, vmPath)
        except KeyError as e:
            apt_shared.logMsg("FAILED TO LOAD INFRASTRUCTURE DATA:" + str(e))
            bailSafely(testVms, devVm)
    elif hyperVisorType.lower() == 'esxi':
        try:
            hypervisorHostname =    infrastructureConfig['HYPERVISOR_HOST']
            hyperVisorPassword =    infrastructureConfig['HYPERVISOR_PASSWORD']
            hyperVisorUsername =    infrastructureConfig['HYPERVISOR_USERNAME']
        except KeyError as e:
            apt_shared.logMsg("FAILED TO LOAD INFRASTRUCTURE DATA:" + str(e))
            bailSafely(testVms, devVm)
        vmServer = esxiVm.esxiServer(hypervisorHostname, hyperVisorUsername, hyperVisorPassword, "443")
        if not vmServer.connect():
            apt_shared.logMsg("[FATAL ERROR]: FAILED TO CONNECT TO " + hypervisorHostname)
            bailSafely(testVms, devVm)
    else:
        apt_shared.logMsg("UNKNOWN hyperVisor TYPE: " + str(hyperVisorType))
        exit
    
    """
    SET THE DEV AND TEST VMS
    """
    vmServer.enumerateVms()
    devVmList   =   apt_shared.findAndConfigVms(vmServer.vmList, [devVmData])
    testVms   =     apt_shared.findAndConfigVms(vmServer.vmList, testVmData)
    if len(devVmList) != 1:
        apt_shared.logMsg("[FATAL ERROR]: COULD NOT PARSE DEV_VM_DATA IN " + testJsonFile)
        bailSafely(testVms, devVm)
    if len(testVms) != len(testVmData):
        apt_shared.logMsg("[WARNING]: SOME TEST VM DATA DID NOT PARSE CORRECTLY!")
        apt_shared.logMsg("FOUND " + str(len(testVms)) + " TEST VMS")
        apt_shared.logMsg("FOUND " + str(len(testVmData)) + " TEST VMS")
    if len(testVms) == 0:
        apt_shared.logMsg("[FATAL ERROR]: COULD NOT PARSE TEST_VM_DATA IN " + testJsonFile)
        bailSafely(testVms, devVm)
    devVm = devVmList[0]
    print testVms
    apt_shared.logMsg("USING DEV VM: " + devVm.vmName)
    apt_shared.logMsg("FOUND " + str(len(testVms)) + " TEST VMS")

    """
    REVERT TEST VMS TO TESTING_BASE
    SNAPSHOT DEV VM
    START ALL THE VMS
    """
    usedVmList = testVms[:]
    usedVmList.append(devVm)
    devVm.takeTempSnapshot()
    for vm in testVms:
        vm.revertToTestingBase()
    for vm in usedVmList:
        vm.prepVm()
    
    """
    WAIT FOR THE VMS TO BE READY
    """
    if not vmServer.waitForVmsToBoot(usedVmList):
        apt_shared.logMsg("ERROR: ONE OR MORE VMS FAILED TO INITIALIZE; EXITING")
        bailSafely(testVms, devVm)
    """
    CREATE REQUIRED DIRECTORY
    """
    for vm in testVms:
        if 'windows' in vm.vmOS.lower():
            vm.makeDirOnGuest(testConfig['WIN_PAYLOAD_DIRECTORY'])
        else:
            vm.makeDirOnGuest(testConfig['NIX_PAYLOAD_DIRECTORY'])
    
    """
    GENERATE LIST OF ALL VMS + APPLICABLE PAYLOADS FOR THAT VM
    """
    msfPath = "/home/" + devVm.getUsername() + "/rapid7/metasploit-framework/"
    localScriptName =    testConfig['SCRIPT_DIR'] + "/" + payloadCreationScript
    remoteScriptName = msfPath + payloadCreationScript
    for i in testVms:
        for j in payloadTypeList:
            if not (('x86' in i.getArch()) and ('x64' in j.lower())):
                i.payloadList.append(apt_shared.makeMetCmd(j, 
                                                           devVm.getVmIp(), 
                                                           i.getVmIp(), 
                                                           str(portNum.get()), 
                                                           cmdList))
    
    remoteCommitFile = msfPath + "commit_tag_" + testConfig['TIMESTAMP']
    apt_shared.makeDevPayloadScript(devVm.getVmIp(), 
                                    msfPath, 
                                    testVms, 
                                    httpPort, 
                                    localScriptName,
                                    remoteCommitFile)
    
    """
    UPLOAD AND RUN THE PAYLOAD GENERATOR/REVERSE HANDLER SCRIPT
    """
    if not devVm.uploadFileToGuest(localScriptName, remoteScriptName):
        apt_shared.logMsg("[FATAL ERROR]: FAILED TO UPLOAD PAYLOAD CREATION SCRIPT TO " + devVm.vmName)
        bailSafely(testVms, devVm)
    chmodCmdList = "/bin/chmod 755".split() + [remoteScriptName]
    if not devVm.runCmdOnGuest(chmodCmdList):
        apt_shared.logMsg("[FATAL ERROR]: FAILED RUN " + ' '.join(chmodCmdList) + " ON " + devVm.vmName)
        bailSafely(testVms, devVm)
    if not devVm.runCmdOnGuest([remoteScriptName]):
        apt_shared.logMsg("[FATAL ERROR]: FAILED RUN " + remoteScriptName + " ON " + devVm.vmName)
        bailSafely(testVms, devVm)
    
    """
    WAIT FOR THE SCRIPT TO FINISH....
    """
    apt_shared.logMsg("WAITING FOR PAYLOADS TO GENERATE...")
    pollingGap = 1
    pollingTimes = 1200
    try:
        for i in range(pollingTimes):
            time.sleep(pollingGap)
            devVm.updateProcList()
            procStr = ' '.join(devVm.procList)
            if payloadCreationScript not in procStr:
                apt_shared.logMsg("PAYLOAD CREATION SCRIPT FINISHED")
                break
            else:
                if i%20 == 0:
                    apt_shared.logMsg("PAYLOAD CREATION SCRIPT STILL RUNNING")
    except KeyboardInterrupt:
        print "CAUGHT KEYBOARD INTERRUPT; SKIPPING WAIT...."
    

    """
    MAKE PYTHON AND/OR BASH(ISH) SCRIPTS FOR TARGET MACHINES TO START PAYLOADS
    """
    remoteInterpreter =     None
    for vm in testVms:
        if 'windows' in vm.vmOS.lower():
            remoteScriptName =  testConfig['WIN_PAYLOAD_DIRECTORY'] + "\\" + testVmScriptName + ".py"
            localScriptName =   testConfig['SCRIPT_DIR'] + "/" + testConfig['TEST_SCRIPT'] + ".py"
            remoteInterpreter = testConfig['PYTHON_PATH']
        else:
            remoteScriptName =  testConfig['NIX_PAYLOAD_DIRECTORY'] + "/" + testVmScriptName + ".sh"
            localScriptName =   testConfig['SCRIPT_DIR'] + "/" + testConfig['TEST_SCRIPT'] + ".sh"
            remoteInterpreter = None
        apt_shared.makeShTestVmScript(devVm.getVmIp(), 
                                      msfPath, 
                                      vm, 
                                      localScriptName, 
                                      testConfig)
        if not vm.uploadAndRun(localScriptName, remoteScriptName, remoteInterpreter):
            apt_shared.logMsg("[FATAL ERROR]: FAILED TO UPLOAD/EXECUTE " + localScriptName + " ON " + vm.vmName)
            bailSafely(testVms, devVm)
    sleepTime = 15
    sleepGap = 7
    for i in payloadTypeList:
        if 'reverse' in i.lower():
            sleepTime = sleepTime + sleepGap
    apt_shared.logMsg("WAITING " + str(sleepTime) + " SECONDS FOR BIND PAYLOAD LISTENERS TO LAUNCH")
    time.sleep(sleepTime)

    
    """
    MAKE BASH SCRIPT TO RUN BIND HANDLERS ON THE DEV VM
    """
    localScriptName = testConfig['SCRIPT_DIR'] + "/" + bindLaunchScript
    remoteScriptName = msfPath + bindLaunchScript
    apt_shared.makeBindLaunchScript(devVm.vmIp, msfPath, testVms, httpPort, localScriptName)
    if not devVm.uploadAndRun(localScriptName, remoteScriptName):
        apt_shared.logMsg("[FATAL ERROR]: FAILED TO UPLOAD/EXECUTE " + localScriptName + " TO " + devVm)
        bailSafely(testVms, devVm)
    
    """
    WAIT FOR THE msfconsole PROCESSES TO FINISH
    """
    apt_shared.logMsg("WAITING FOR METERPRETER PROCESSES TO FINISH")
    pollingGap = 10
    pollingTimes = 10 + (len(testVms) * len(payloadTypeList))
    try:
        for i in range(pollingTimes):
            msfconsoleCount = 0
            time.sleep(pollingGap)
            devVm.updateProcList()
            for j in devVm.procList:
                if 'msfconsole' in j.lower():
                    apt_shared.logMsg(j)
                    msfconsoleCount = msfconsoleCount + 1
            msgOut = str(msfconsoleCount) + \
                     " msfconsole PROCESSES RUNNING; ABORTING IN " + \
                     str(pollingGap * (pollingTimes - i)) + " SECONDS."
            apt_shared.logMsg(msgOut)
            if 0 == msfconsoleCount:
                break
    except KeyboardInterrupt:
        print "CAUGHT KEYBOARD INTERRUPT; SKIPPING WAIT...."

    """
    PULL REPORT FILES FROM EACH TEST VM
    """
    apt_shared.logMsg("GETTING REPORT FILES FROM VMS")
    reportFiles = []
    for i in testVms:
        for j in i.payloadList:
            srcFile = msfPath + "/" + j.rcScriptName + ".out"
            dstFile = testConfig['SESSION_DIR'] + "/" + j.rcScriptName + ".out"
            devVm.getFileFromGuest(srcFile, dstFile)
            reportFiles.append(dstFile)
    apt_shared.logMsg("FINISHED DOWNLOADING VM REPORTS")
    
    """
    GET COMMIT VERSION
    """
    srcFile = remoteCommitFile
    dstFile = testConfig['REPORT_DIR'] + "/commit_" + testConfig['TIMESTAMP'] + ".txt"
    devVm.getFileFromGuest(srcFile, dstFile)
    try:
        fileObj = open(dstFile, 'r')
        commitRaw = fileObj.read().strip()
        fileObj.close()
    except IOError as e:
        apt_shared.logMsg("FAILED TO OPEN " + dstFile)
        apt_shared.logMsg("SYSTEM ERROR: \n" + str(e))
    else:
        commitVersion = commitRaw.split(' ')[1]
        apt_shared.logMsg("COMMIT VERSION OF metasploit-framework: " + commitVersion)
    
    """
    RETURN ALL TESTING VMS TO TESTING_BASE
    RETURN DEV VM TO WHERE WE FOUND IT
    POWER OFF ALL VMS
    """
    devVm.revertDevVm()
    devVm.powerOff()
    for i in testVms:
        i.revertToTestingBase()
        i.powerOff()

    """
    COALLATE DATA
    """
    resultDict = apt_shared.populateResults(reportFiles, testVms, testConfig)

    """
    GENERATING REPORT
    """
    apt_shared.logMsg("GENERATING MAIN REPORT")
    reportFileName = testConfig['REPORT_DIR'] + "/" + reportPrefix
    with open(reportFileName + ".json", 'wb') as jsonFile:
        json.dump(resultDict, jsonFile) 
    reportFile = apt_shared.generateReport(reportFiles, testVms, reportFileName + ".txt", testConfig['SESSION_DIR'], commitVersion)
    apt_shared.logMsg("REPORT GENERATION COMPLETE, REPORT FILE: " + reportFile)
    apt_shared.makeWebResults(testVms, reportFileName + ".old.html")
    if not apt_shared.generateHtmlReport(resultDict, reportFileName + ".html", testVms, commitVersion, testConfig):
        apt_shared.logMsg("FAILED TO GENERATE HTML REPORT")
    else:
        apt_shared.logMsg("HTML REPORT AVAILABLE HERE: " + reportFileName + ".html")

    apt_shared.logMsg("WAITING FOR ALL TASKS TO COMPLETE")
    time.sleep(5)
    apt_shared.logMsg("EXIT")
    
if __name__ == "__main__":
    main()
    